#ייבוא ספריות
import cv2
import numpy as np
from matplotlib import pyplot as plt
from PIL import Image

#פונקציה לאיתור ונירמול קשתית העין המקבלת את הווקטור של התמונה
#ומקבלת את מודל הסגמנטציה במידת הצורך, תלוי אם נרצה להשתמש בו או לא
def IrisImgNormalization(img, model=None):

    #numpy על אותו פורמט ולכן נמיר את התמונה למערך של  cv2 אבל אי אפשר להשתמש בפעולות  ,PILכשאר אנחנו מייבאים את התמונה לממש, אנחנו משתמשים ב
    img = np.asarray(img)

    #אם אין צורך בסגמנטציה אז נפעל כרגיל
    if model is None:
        
        #נשכפל את התמונה כדי שנוכל להתעסק איתה מבלי להרוס את המקור
        original = img.copy()

        #דורש רק תמונות בשחור לבן HoughCircles נמיר לשחור לבן מאחר והאלגוריתם
        filter = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        #בפונקציית טישטוש שעוזרת להפשיט את התמונה ולהבין מהפרטים הכללים איפה נמצאים העיגולים שיסמנו את הקשתית החזקים בתמונה
        #cv2.medianBlur - טישטוש התמונה בחוזק של 21
        filter = cv2.medianBlur(filter, 21)
        #אלגוריתם למציאת עיגולים בתמונה
        #cv2.HOUGH_GRADIENT - Threshold זו השיטה למציאת העיגולים בה אנחנו הופכים את התמונה לתמונה מופשטת של קווי 
        #dp יחס בין התמונה למטריצה עליה מסומנות הנקודות שאחר כך מזוכות כמרכזי עיגולים
        #minDist - המרחק המינימלי בין מרכזי העיגולים
        #param1 - של תמונת זיוהוי הקצוות שעליה כל האלגוריתם הזה עובד, זה ערך שמשחקים איתו בין דאטה לדאטה מאחר והוא משפיע בצורה שונה על תמונות שונות Thresholdערך ה
        #param2 - ערך שמגדיר את רגישות האלגוריתם, אם הוא גבוה מידי אז הוא לא ימצא עיגולים ואם הוא נמוך מידי אז הוא ימצא יותר מידי עיגולים
        #minRadius - רדיוס מינימלי של העיגול
        #maxRadius - רדיוס מקסימלי של העיגול
        detected_circles = cv2.HoughCircles(
            filter, cv2.HOUGH_GRADIENT, dp=3, minDist=20,
            param1=50, param2=20, minRadius=60, maxRadius=105
        )
        #אם לא נמצא עיגול, לא נרצה שהקוד ייקרוס אלה יחזיר שערך שלילי והודעת שגיאה
        if detected_circles is None:
            print("Did not find iris")
            return None
        
        #אם כן מצאנו עיגולים אז אנחנו רוצים להמיר את מטריצת העיגולים למספרים שלמים
        #np.uint16 - ממיר את המטריצה למספרים שלמים
        #np.around - מעגל כל ערך במערך למספר השלם הקרוב ביותר
        #נגדיר את מיקום העיגול הראשון שנמצא כי בדרך כלל הוא המדויק ביותר
        #A - מיקום ה-X של העיגול
        #B - מיקום ה-Y של העיגול
        #R - רדיוס העיגול
        A, B, R = np.uint16(np.around(detected_circles))[0, 0]


        #אותו אלגוריתם למציאת עיגולים רק הפעם בשביל באישון
        #הערכים שונים מאחר והאישון דומיננטי יותר וקטן יותר ונוכל לעזור לאלגוריתם למצוא אותו בעזרת הערכים הנכונים 
        #משתמשים באותה תמונה מטושטשת כמו בפעם הראשונה
        detected_circles = cv2.HoughCircles(
        filter, cv2.HOUGH_GRADIENT, 1, 50, param1=80,
        param2=15, minRadius=1, maxRadius=50
        )

        #שוב פעם אם מצאנו את האישון אז נרצה להמיר את המטריצה למספרים שלמים ועגולים ואם לא אז נחזיר ערך שלילי ונדפיס שגיאה
        if detected_circles is None:
            print("Did not find pupil")
            return None
        
        #אם כן מצאנו עיגולים אז אנחנו רוצים להמיר את מטריצת העיגולים למספרים שלמים ולבחור את העיגול הראשון שנמצא כי לרוב הוא הכי מדויק
        a, b, r = np.uint16(np.around(detected_circles))[0, 0]

        #עכשיו נרצה לחתוך את התמונה שיישאר רק העין בדיוק כלומר רק הקשתית והאישון, מאחר ולפעמים מעגל האישון נמצא בחלקו מחוץ לתמונה
        #שמוודאת שהערך המינימלי יהיה 0 max( ,0) נצטרך לוודא שאנחנו לא חותכים ערכים שליליים של התמונה שלא קיימים אחרת נקבל שגיאה ולכן נשתמש בפעולה
        H, W = original.shape[:2]
        left = max(0, int(a) - int(R))
        top = max(0, int(b) - int(R))
        right = min(W, int(a) + int(R))
        bottom = min(H, int(b) + int(R))

        #נחתוך את התמונה לפי הערכים שהגדרנו למעלה
        cropped = original[top:bottom, left:right]

        #נגדיר את מרכז האישון והקשתית החדש לאחר שחתכנו את התמונה
        iris_center = (a - left, b - top)
        #נגדיר את האורך והרוחב הרצוי של התמונה החדשה שתהיה מלבנית
        output_size = (400, 150)

        #המרה מייצוג פולרי לייצוג קרטזי
        #np.linspace - מחזיר מערך של מספרים בין שני ערכים
        theta = np.linspace(0, 2 * np.pi, output_size[0])
        r = np.linspace(r, R, output_size[1])

        #שבכל מטריצה הערכים שבמערך מייצגים פיקסל Theta או  R מחזיר שתי מטריות בגודל האורך של

        # r = [1, 2, 3]
        #                 הופך להיות  
        # R = [[1, 2, 3],
        #      [1, 2, 3],
        #      [1, 2, 3]]
        R_grid, Theta_grid = np.meshgrid(r, theta)

        #עכשיו נחשב את הנקודות בתמונה של העין לפי המרחק והזווית היחסית כמו במרוכבים
        Xs = iris_center[0] + R_grid * np.cos(Theta_grid)
        Ys = iris_center[1] + R_grid * np.sin(Theta_grid)

        #ונמפה מחדש את התמונה לפי הנקודות החדשות שהגדרנו כך שכל נקודה בקשתית שביחד הן עיגול תמפה כל נקודה בתמונה החדש כמלבן
        img = cv2.remap(cropped, Xs.astype(np.float32), Ys.astype(np.float32), cv2.INTER_LINEAR)
        #נסובב את המלבן 90 מעלות כדי שיישכב לצורך נוחות
        img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)

        #עכשיו נרצה לקחת את האורח והרוחב של התמונה ולהוריד מלמטה חצי כלומר לחתוך ולהעלים את החצי התחתון של התמונה
        #מאחר וברוב המקרים זה יוצא שהחלק התחתון של התמונה מהווה את האפפיים או הריסים של העין
        H, W = img.shape[:2]
        #נחתוך את החלק התחתון של התמונה
        img = img[10:(H // 2) + 10, 0:W]

        #נחזיר את התמונה החדשה והמנורמלת של קשתית העין
        return img
    
    #אם יש צורך נדאג להשתמש במודל הסגמנטציה
    if model is not None:
        #נגדיר את מצב הריבוע לכבוי כרגע ואם נגלה שיש צורך להשתמש בו נדליק אותו בהמשך
        #מצב ריבוע הוא מצב בו לפי נוסחה המראה על קרבת צורה מסוימת לרביוע הוא גבוה אז נשתמש באלגוריתם למציאת עיגול על התוצאה של הסגמנטציה
        #אם המצב כבוי כלומר התוצאה של הסגמנטציה יותר מלבנית אז נשתמש בשיטה של לקחת את שני הפיקסלים הרחוקים ביותר אחד מהשני כלומר הקצוות ולבנות מהם עיגול
        square = False

        #נקטין את התמונה לגודל המתאים לקלט מודל הסגמנטציה
        target_size = (128, 128)
        #נשכפל את התמונה כדי שנוכל להתעסק איתה מבלי להרוס את המקור
        test_img = img.copy()

        #כאן אנחנו בודקים אם התמונה היא דו ממדית אנחנו צריכים להפוך אותה לתלת ממדית לכן מכפילים אותה שלוש פעמים ויוצרים מימד שלישי צבעוני
        #אנחנו עושים זאת על מנת שנכניס את התמונה למודל הסגמנטציה שמקבל רק תמונות תלת ממדיות
        if test_img.ndim == 2:
            test_img = np.stack([test_img] * 3, axis=-1)

        #כאן אנחנו בודקים אם איכשהו לתמונה יש 4 ממדים אז גם אותה נהפוך לתל ממדית מאחר וזה מה שהמודל מקבל
        elif test_img.shape[-1] == 4:
            test_img = test_img[:, :, :3]


        dims = test_img.shape[:2]

        #בכדי שנוכל לעשות עליו פונקציית שינוי גודל תמונה Pillow כאן אנחנו ממירים את התמונה לאובייקט מסוג 
        #נשנה את התמונה לגודל שקבענו מקודם
        #128x128
        test_img = Image.fromarray(test_img).resize(target_size)
        #כדי שנוכל להכניס אותו למודל Numpy ונמיר אותה חזרה למערך 
        #np.array(test_img) ממיר את התמונה למערך
        #astype("float32") כי זה ברירת המחדל כשעובדים עם מודלים float32ממיר את הערכים ל
        #בגדול זה בגלל שיש יותר ביטים והמספר הופך להיות יותר מדויק ולא מתעגל
        #לאחר מכן נחלק ב255 בכדי לנרמל את התמונה
        test_img = np.array(test_img).astype("float32") / 255.0
        # "מזוייף" batch עכשיו ההכנה האחרונה לפני שמכניסים למודל זה להוסיף 
        #'אנחנו עושים את זה כי כשהגדרנו את המודל, הגדרנו אותו כך שלקלט יש ממד באטצ
        #axis=0 בכדי להכניס אותו בהתחלה לםני שאר הממדים
        test_img = np.expand_dims(test_img, axis=0)

        #נחזה את מסיכת הקשתית בעזרת מודל הסגמנטציה
        #.predict היא פונקציית הפעלת המודל
        #[0] כדי להוציא את התמונה מתוך הבאטצ' שלה
        pred_mask = model.predict(test_img)[0]
        # 1עכשיו מכיוון שהמסיכה מגיעה בשחור לבן כלומר עם ממד שלישי השווה ל
        # 1אז נרצה להסיר אותו בעזרת פונקציה שמסירה כל ממד השווה ל
        pred_mask = np.squeeze(pred_mask)

        #עכשיו מכיוון שלא נרצה חלקים אפורים בתמונה שיבלבלו אותנו אחר כך, נצטרך להפוך את הערכים או ל0 או ל1
        #לכן נגדיר את התקרה, כלומר כל מה שמעל חצי יהפוך ל1 ולהפך יהפוך ל0
        threshold = 0.5
        #זאת הפונקציה שמממשת בדיוק את זה, כל מה שמעל חצי יגרום לתנאי להפוך לחיובי כלומר 1 ולהפך שלילי כלומר 0
        binary_mask = (pred_mask > threshold).astype(np.uint8)

        #כאן אנחנו מחזירים את המסיכה לגודל התמונה המקורית בכדי שנוכל להמשיך לעבוד איתה
        #interpolation=cv2.INTER_NEAREST זה האלגוריתם להגדלת התמונות, ספציפית מה שבחרנו עושה ממוצע של כמה פיקסלים קרובים כאשר הוא רוצה לחשב פיקסל חדש
        binary_mask = cv2.resize(binary_mask, (dims[1], dims[0]), interpolation=cv2.INTER_NEAREST)
        #'גם מהתמונה המקורית צריך להיפטר מהממד באטצ
        img = test_img[0]
        #וגם אותה צריך להגדיל בחזרה לגודל המקורי באותה הצורה ובאותו אלגוריתם הגדלה
        img = cv2.resize(img, (dims[1], dims[0]), interpolation=cv2.INTER_LINEAR)

        #עכשיו ניצור גם מסיכה הפוכה בכדי שבהמשך נוכל להשתמש בה למציאת האישון ולא הקשתית
        #הפוכה כלומר כל מה שהיה 1 יהפוך ל0 ולהפך
        revert_binary_mask = 1 - binary_mask
        #את שתי המסיכות נרצה להחזיר לערכים של 0-255 בכדי שנוכל להשתמש במספר פונקציות בהמשך
        binary_mask = (binary_mask * 255).astype(np.uint8)
        revert_binary_mask = (revert_binary_mask * 255).astype(np.uint8)

        #כאן נבנה תנאי המחזיר שגיאה כאשר קיבלנו מסיכה ריקה לגמרי
        if binary_mask is None or binary_mask.size == 0 or np.sum(binary_mask) == 0:
            raise ValueError("Binary mask is empty or invalid. Check segmentation output.")

        #נגדיר את משתני המיקום של המעגל בכדי שאחר כך נוכל לקבל אותם מהפונקציה של מציאת העיגולים
        A, B, R = 0, 0, 0

        #נשכפל את התמונה כדי שנוכל להתעסק איתה מבלי להרוס את המקור
        img = img.copy()

        #תיצור מטריצה של פיקסלים רק מעל הערך 150 שהם לבנים מספיק
        white_pixels = np.column_stack(np.where(binary_mask >= 150))

        #אם יש לפחות ערך 1 לבן
        if white_pixels.size > 0:
            #תן לי את הנקודה של פינה שמאל למטה של המטריצה
            y_min, x_min = white_pixels.min(axis=0)
            #תן לי את הנקודה ימין למעלה של המטריצה
            y_max, x_max = white_pixels.max(axis=0)

        #עכשיו יוצרים את ממדי הקופסא החדשה המקיפה בדיוק את המסיכה של הקשתית שיצר לנו מודל הסגמנטציה
        box_width = x_max - x_min
        box_height = y_max - y_min

        #נוסחה לחישוב קירוב מרובע לריבוע
        #ערכים בין 0-1 כש1 נחשב לריבוע מושלם
        square_sim = 1 - abs(box_height / box_width - 1)

        #נגדיר את ערך המינימום שנחשב לריבוע - 75
        #כל מה שמתחת הוא מלבן (אליפסה)
        if square_sim > 0.75:
            square=True

        #METHOD 1 ---------------------------------------
        #אופציה ראשונה אם המסיכה של הקשתית מלבנית כלומר יותר דומה לאליפסה אז כנראה המודל פספס חלק מהמעגל והשאיר לנו אליפסה לכן בשביל
        # למצוא את העיגול השלם פשוט ניקח את שתי הנקודות ההכי ימנית וההכי שמאלית ואלו יהיו הנקודה הכי ימנית והכי שמאלית על המעגל האמיתי וכך המצא אותו
        if not square:
            #אם התמונה צבעונית נמיר אותה לשחור לבן
            #כי אחרי הכל אנחנו רוצים לחפש פיקסלים, והכי קל לעבוד עם פיסקלים שחורים ולבנים
            if len(img.shape) == 3:
                img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

            #נגדיר שני משתנים השווים לאורך ורוחב התמונה
            height, width = img.shape[0:2]

            #נאתחל לכרגע את הערך המקסימלי לנקודה הכי שמאלית שיהיה הצד הכי ימני כדי שאם יש משהו שמאלי ממנו נעדכן את המשתנה
            leftmost = width
            #הכי ימני כרגע זה הכי שמאלי בדיוק מאותה הסיבה
            rightmost = 0
            #של הנקודה הכי שמאלית חלקי 2 כלומר נקודת הגובה שבין שתי הנקודות yשל הנקודה הכי ימנית ועוד ה  yונקודת המרכז עוד מעט יהיו ה
            #כרגע נאתחל אותן ל0
            middlepoint1 = 0
            middlepoint2 = 0

            #כלומר על כל עמודה yנעבור על כל ערך
            for y in range(height):
                #בתוך כל עמודה, נעבור בכל שורה 
                for x in range(width):
                    #ונבדוק אם הנקודה במיקום הזה היא גדולה מ0 כלומר לבנה
                    if binary_mask[y, x] > 0:
                        #אם כן אז נבדוק אם היא שמאלית יותר מהנקודה הכי שמאלית כרגע
                        if x < leftmost:
                            #אם כן נהפוך אותך להיות הנקודה השמאלית ביותר החדשה
                            leftmost = x
                            #ונעדכן את הגובה שלה
                            middlepoint = y
                        #אם כן אז נבדוק אם היא ימנית יותר מהנקודה הכי ימנית כרגע
                        if x > rightmost:
                            #אם כן נהפוך אותך להיות הנקודה הימנית ביותר החדשה
                            rightmost = x
                            #ונעדכן את הגובה שלה
                            middlepoint2 = y

            #מרכז המעגל כמו שאמרנו יהיה בדיוק בין שתי הנקודות
            A = (leftmost + rightmost) // 2
            #והרדיוס שלו יהיה המרחק חלק 2 כלומר חצי קוטר
            R = (rightmost - leftmost) // 2
            #גם גובה מרכז המעגל יהיה בין שתי נקודות הגובה 
            B = middlepoint2+middlepoint1 // 2

        #METHOD 2 ---------------------------------------
        #אופציה שניה היא במקרה והקשתית קרובה לריבוע כלומר יותר דומה לעיגול מושלם אז פשוט נבצע את האלגוריתם על המסיכה שלה
        else:
            #אותו אלגוריתם למציאת עיגולים רק הפעם בשביל באישון
            #הערכים שונים מאחר והאישון דומיננטי יותר וקטן יותר ונוכל לעזור לאלגוריתם למצוא אותו בעזרת הערכים הנכונים 
            #משתמשים באותה תמונה מטושטשת כמו בפעם הראשונה
            detected_circles = cv2.HoughCircles(
            binary_mask, cv2.HOUGH_GRADIENT, 3, 200, param1=50,
            param2=15, minRadius=60, maxRadius=285
            )

            #אם לא נמצא עיגול, לא נרצה שהקוד ייקרוס אלה יחזיר שערך שלילי והודעת שגיאה
            if detected_circles is None:
                print("No iris detected. Skipping frame")
                return None

            #אם כן מצאנו עיגולים אז אנחנו רוצים להמיר את מטריצת העיגולים למספרים שלמים ונבחר את העיגול הראשון שנמצא כי לרוב הוא הכי מדויק
            A, B, R = np.uint16(np.around(detected_circles))[0, 0]

        #-----------------------------------------------

        #נשכפל את התמונה כדי שנוכל להתעסק איתה מבלי להרוס את המקור
        img = img.copy()

        #עכשיו נרצה לחתוך את צידי התמונה כך שכל מה שישאר לנו זה האישון וקצת מסביבו בכדי שיהיה לנו סיכוי קטן יותר לפספס אותו
        #נעשה זאת על ידי לקיחת המסיכה של הקשתית הפיכתה, כלמור עכשיו במקום לסמן את הקשתית היא מסמנת את האישון, ולאחר שמצאנו את האישון נוכל לעשות לו זום אין
        # ובמקום לטשטש תמונה ואז להשתמש באלגוריתם נשתמש במסיכה ההפוכה לאחר טישטוש כדי להגדיל את סיכויי הסימון של האישון

        #נהפוך את המסיכה של הקשתית כלומר שתהיה מסיכה של האישון
        edges = cv2.Canny(revert_binary_mask, 50, 150)
        #ניתן לה אפקט טישטוש
        edges = cv2.blur(edges, (5, 5))

        #נבחר כמה נרצה לחתוך מצידי הקשתית כלומר כמה זום אין לעשות
        #אם המסיכה של הקשתית היא מלבנית אז נעשה פחות זום אין מכיוון שיש פחות מקום בפנים
        cutter = R/4

        #כי אם היא מלבנית זה אומר שהיא כמו ריבוע שמתחו אותו ולכן נרצה לעשות יותר זום אין
        if not square:
            cutter = R/2

        #בנצע חישוב של איפה תמצא כל דופן בתמונה החדשה
        left = A - R + cutter
        top = B + R - cutter
        right = A + R - cutter
        bottom = B - R + cutter

        #ונחתוך אותה וכביכול נעשה זום אין
        edges = edges[int(bottom):int(top), int(left):int(right)]
        
        #אותו אלגוריתם למציאת עיגולים רק הפעם בשביל באישון
        #הערכים שונים מאחר והאישון דומיננטי יותר וקטן יותר ונוכל לעזור לאלגוריתם למצוא אותו בעזרת הערכים הנכונים 
        #משתמשים באותה תמונה מטושטשת כמו בפעם הראשונה
        detected_circles = cv2.HoughCircles(
        edges, cv2.HOUGH_GRADIENT, 1, 90, param1=70,
        param2=15, minRadius=20, maxRadius=70
        )

        #אם לא נמצא עיגול, לא נרצה שהקוד ייקרוס אלה יחזיר שערך שלילי והודעת שגיאה
        if detected_circles is None:
            print("Breaked, Did not find Pupil")
            return None

        #אם כן מצאנו עיגולים אז אנחנו רוצים להמיר את מטריצת העיגולים למספרים שלמים ולבחור את העיגול הראשון שנמצא כי לרוב הוא הכי מדויק
        a, b, r = np.uint16(np.around(detected_circles))[0, 0]

        #מכיוון שמצאנו את הקורדינטות של האישון בהגדלה, הקורדינטות לא מתאימות לתמונה המקורית ולכן נצטרך להתאים אותן חזרה
        a = a + int(A - R + cutter)
        b = b + int(B - R + cutter)

        #עכשיו נרצה לחתוך את התמונה שיישאר רק העין בדיוק כלומר רק הקשתית והאישון, מאחר ולפעמים מעגל האישון נמצא בחלקו מחוץ לתמונה
        #שמוודאת שהערך המינימלי יהיה 0 max( ,0) נצטרך לוודא שאנחנו לא חותכים ערכים שליליים של התמונה שלא קיימים אחרת נקבל שגיאה ולכן נשתמש בפעולה
        H, W = img.shape[:2]
        left = max(0, int(A)-int(R))
        top = max(0, int(B)-int(R))
        right = min(W, int(A)+int(R))
        bottom = min(H, int(B)+int(R))

        #בטווח 0-255 uint8 בכדי לבצע מספר פעולות, נרצה להמיר אותה לפורמט  PIL מאחר וערכי התמונה כרגע בטווח בין 0-1 ואנחנו רוצים להמיר את התמונה לאובייקט
        img = (img * 255).astype(np.uint8) if img.dtype == np.float32 else img
        #PIL עכשיו נמיר לאובייקט
        # img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        img = Image.fromarray(img)

        #נחתוך את התמונה לפי הערכים שהגדרנו למעלה
        img = img.crop((left, top, right, bottom))

        #numpy בשביל להפוך את עיגול הקשתית למלבן נצטרך להפעיל פעולו שעובדות רק על מערך 
        img = np.array(img)

        #נגדיר את מרכז האישון והקשתית החדש לאחר שחתכנו את התמונה
        iris_center = (a - left, b - top)
        #נגדיר את האורך והרוחב הרצוי של התמונה החדשה שתהיה מלבנית
        output_size = (400, 150)

        #המרה מייצוג פולרי לייצוג קרטזי
        #np.linspace - מחזיר מערך של מספרים בין שני ערכים
        theta = np.linspace(0, 2 * np.pi, output_size[0])
        r = np.linspace(r, R, output_size[1])

        #שבכל מטריצה הערכים שבמערך מייצגים פיקסל Theta או  R מחזיר שתי מטריות בגודל האורך של

        # r = [1, 2, 3]
        #                 הופך להיות  
        # R = [[1, 2, 3],
        #      [1, 2, 3],
        #      [1, 2, 3]]
        R_grid, Theta_grid = np.meshgrid(r, theta)

        #עכשיו נחשב את הנקודות בתמונה של העין לפי המרחק והזווית היחסית כמו במרוכבים
        Xs = iris_center[0] + R_grid * np.cos(Theta_grid)
        Ys = iris_center[1] + R_grid * np.sin(Theta_grid)

        #ונמפה מחדש את התמונה לפי הנקודות החדשות שהגדרנו כך שכל נקודה בקשתית שביחד הן עיגול תמפה כל נקודה בתמונה החדש כמלבן
        img = cv2.remap(img, Xs.astype(np.float32), Ys.astype(np.float32), cv2.INTER_LINEAR)
        #נסובב את המלבן 90 מעלות כדי שיישכב לצורך נוחות
        img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)

        #עכשיו נרצה לקחת את האורח והרוחב של התמונה ולהוריד מלמטה חצי כלומר לחתוך ולהעלים את החצי התחתון של התמונה
        #מאחר וברוב המקרים זה יוצא שהחלק התחתון של התמונה מהווה את האפפיים או הריסים של העין
        H, W = img.shape[:2]
        #נחתוך את החלק התחתון של התמונה
        img = img[10:(H // 2) + 10, 0:W]

        #נחזיר את התמונה החדשה והמנורמלת של קשתית העין
        return img