#ייבוא ספריות
import cv2
import numpy as np
from PIL import Image
from skimage.io import imread

#פונקציה לאיתור ונירמול קשתית העין המקבלת את הנתיב של התמונה
def IrisURLNormalization(path):

  #נייבא את התמונה מהנתיב
  #cv2.IMREAD_GRAYSCALE - מייבא את התמונה בשחור לבן מאחר וזה הצבע שלה בדאטה-סט
  filter = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
  #בפונקציית טישטוש שעוזרת להפשיט את התמונה ולהבין מהפרטים הכללים איפה נמצאים העיגולים שיסמנו את הקשתית החזקים בתמונה
  #cv2.medianBlur - טישטוש התמונה בחוזק של 21
  filter = cv2.medianBlur(filter, 21)

  #אלגוריתם למציאת עיגולים בתמונה
  #cv2.HOUGH_GRADIENT - Threshold זו השיטה למציאת העיגולים בה אנחנו הופכים את התמונה לתמונה מופשטת של קווי 
  #dp יחס בין התמונה למטריצה עליה מסומנות הנקודות שאחר כך מזוכות כמרכזי עיגולים
  #minDist - המרחק המינימלי בין מרכזי העיגולים
  #param1 - של תמונת זיוהוי הקצוות שעליה כל האלגוריתם הזה עובד, זה ערך שמשחקים איתו בין דאטה לדאטה מאחר והוא משפיע בצורה שונה על תמונות שונות Thresholdערך ה
  #param2 - ערך שמגדיר את רגישות האלגוריתם, אם הוא גבוה מידי אז הוא לא ימצא עיגולים ואם הוא נמוך מידי אז הוא ימצא יותר מידי עיגולים
  #minRadius - רדיוס מינימלי של העיגול
  #maxRadius - רדיוס מקסימלי של העיגול
  detected_circles = cv2.HoughCircles(
  filter, cv2.HOUGH_GRADIENT, dp=3, minDist=20, param1=30,
  param2=10, minRadius=60, maxRadius=105
  )
  #אם לא נמצא עיגול, לא נרצה שהקוד ייקרוס אלה יחזיר שערך שלילי והודעת שגיאה
  if detected_circles is None:
      #אם לא מצאנו עיגולים אז אנחנו רוצים להחזיר הודעת שגיאה וערך שלילי
      print("Breaked, Did not find Iris")
      return False
  
  #אם כן מצאנו עיגולים אז אנחנו רוצים להמיר את מטריצת העיגולים למספרים שלמים
  #np.uint16 - ממיר את המטריצה למספרים שלמים
  #np.around - מעגל כל ערך במערך למספר השלם הקרוב ביותר
  #נגדיר את מיקום העיגול הראשון שנמצא כי בדרך כלל הוא המדויק ביותר
  #A - מיקום ה-X של העיגול
  #B - מיקום ה-Y של העיגול
  #R - רדיוס העיגול
  A, B, R = np.uint16(np.around(detected_circles))[0, 0]

  #מייבאים שוב את התמונה מאחר והרסנו אותה עם הטישטוש בהתחלה
  img = imread(path, cv2.IMREAD_GRAYSCALE)

  #מוסיפים עיגול אדום מסביב לקשתית על התמונה המקורית
  #שלב זה נועד רק לכך שנוכל לראות את ההתקדמות של הפונקציה והוא
  cv2.circle(img, (A, B), R, (255, 0, 0), 2)

  #אותו אלגוריתם למציאת עיגולים רק הפעם בשביל באישון
  #הערכים שונים מאחר והאישון דומיננטי יותר וקטן יותר ונוכל לעזור לאלגוריתם למצוא אותו בעזרת הערכים הנכונים 
  #משתמשים באותה תמונה מטושטשת כמו בפעם הראשונה
  detected_circles = cv2.HoughCircles(
  filter, cv2.HOUGH_GRADIENT, 1, 50, param1=60,
  param2=23, minRadius=10, maxRadius=70
  )

  #שוב פעם אם מצאנו את האישון אז נרצה להמיר את המטריצה למספרים שלמים ועגולים ואם לא אז נחזיר ערך שלילי ונדפיס שגיאה
  if detected_circles is None:
      print("Did not find pupil")
      return None
  
  #אם כן מצאנו עיגולים אז אנחנו רוצים להמיר את מטריצת העיגולים למספרים שלמים ולבחור את העיגול הראשון שנמצא כי לרוב הוא הכי מדויק
  a, b, r = np.uint16(np.around(detected_circles))[0, 0]

  #נייבא תמונה חדשה כי על התמונה הקודמת כבר ציירנו ועכשיו אנחנו לא רוצים רק להוסיף ציור של האישון אלה גם להתאים את מרכז הקשתית
  #עם מרכז האישון כלומר שהמעגל של האישון יישב בדיוק בתוך במעגל של הקשתית כדי שלאחר מכן נוכל לשהתמש בנוסחה של המרת קורדינטות ולהפוך את התמונה למלבן
  #אנחנו מביאים דווקא את המעגל של הקשתית אל המעגל של האישון מהסיבה הפשוטה שהמעגל של האישון יותר מדויק כי יותר קל למצוא אותה, הוא בולט יותר ולכן אם אנחנו
  # יותר בטוחים במיקום האישון והאישון תמיד נמצא במרכז הקשתית אז נוכל למצוא ככה את הקשתית בצורה מדויקת יותר
  #אז למה בכל זאת ניסינו בהתחלה למצוא את הקשתית - בכדי שנדע מה הרדיוס שלה
  img = cv2.imread(path, cv2.IMREAD_COLOR)

  #עכשיו נרצה לחתוך את התמונה שיישאר רק העין בדיוק כלומר רק הקשתית והאישון, מאחר ולפעמים מעגל האישון נמצא בחלקו מחוץ לתמונה
  #שמוודאת שהערך המינימלי יהיה 0 max( ,0) נצטרך לוודא שאנחנו לא חותכים ערכים שליליים של התמונה שלא קיימים אחרת נקבל שגיאה ולכן נשתמש בפעולה
  H, W = img.shape[:2]
  left = max(0, int(a)-int(R))
  top = max(0, int(b)-int(R))
  right = min(W, int(a)+int(R))
  bottom = min(H, int(b)+int(R))

  #עובד רק עם הפורמט הזה .crop() מאחר ו  RGBנהפוך את פורמט התמונה ל
  img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
  #נחתוך את התמונה לפי הערכים שהגדרנו למעלה
  img = img.crop((left, top, right, bottom))

  #אז נמיר את התמונה כבר עכשיו Numpy עכשיו מאחר ועוד מעט נשתמש בפעולות שדורשות מערך
  img = np.array(img)

  #נגדיר את מרכז האישון והקשתית החדש לאחר שחתכנו את התמונה
  iris_center = (a-left, b-top)
  #נגדיר את האורך והרוחב הרצוי של התמונה החדשה שתהיה מלבנית
  output_size = (400, 150)

  #המרה מייצוג פולרי לייצוג קרטזי
  #np.linspace - מחזיר מערך של מספרים בין שני ערכים
  theta = np.linspace(0, 2 * np.pi, output_size[0])
  r = np.linspace(r, R, output_size[1])

  #שבכל מטריצה הערכים שבמערך מייצגים פיקסל Theta או  R מחזיר שתי מטריות בגודל האורך של

  # r = [1, 2, 3]
  #                 הופך להיות  
  # R = [[1, 2, 3],
  #      [1, 2, 3],
  #      [1, 2, 3]]
  R_grid, Theta_grid = np.meshgrid(r, theta)


  #עכשיו נחשב את הנקודות בתמונה של העין לפי המרחק והזווית היחסית כמו במרוכבים
  Xs = iris_center[0] + R_grid * np.cos(Theta_grid)
  Ys = iris_center[1] + R_grid * np.sin(Theta_grid)

  #ונמפה מחדש את התמונה לפי הנקודות החדשות שהגדרנו כך שכל נקודה בקשתית שביחד הן עיגול תמפה כל נקודה בתמונה החדש כמלבן
  img = cv2.remap(img, Xs.astype(np.float32), Ys.astype(np.float32), cv2.INTER_LINEAR)
  #נסובב את המלבן 90 מעלות כדי שיישכב לצורך נוחות
  img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)

  #עכשיו נרצה לקחת את האורח והרוחב של התמונה ולהוריד מלמטה חצי כלומר לחתוך ולהעלים את החצי התחתון של התמונה
  #מאחר וברוב המקרים זה יוצא שהחלק התחתון של התמונה מהווה את האפפיים או הריסים של העין
  H, W = img.shape[:2]

  #נחתוך את החלק התחתון של התמונה
  img = img[10:(H//2)+10, 0:W]

  #נחזיר את התמונה החדשה והמנורמלת של קשתית העין
  return img
